using System;
using System.Collections.Generic;
using System.Text;

namespace Chucklepie.GodotTileMap
{
    /// <summary><para>
    /// Create a Godot scene file (.tscn) from supplied data via a builder
    /// The scene file is a tilemap with tileset, and with or without a generated tilemap level
    /// All defaults are set to sensible values but as a minimum the following should be supplied/set in order to work:
    /// </para>
    /// - SetTileSheet: the name of the graphics file you will supply containing the grid of graphics
    /// - SetCellSize: size in pixels of each graphic within the tilesheet (e.g. 32x32 sub-images)
    /// - SetTileSheetSizeUnits: The number of cells in the tilesheet graphic(e.g. 10x10 for a 320x320 graphic with 32 pixel items)
    /// - SetTileSheetStartIndex: what index the first tile in the tilesheet is. Typically 0 or 1
    /// 
    /// If you want the map to be produced and drawn on screen, rather than just the tileset:
    /// 
    /// - SetMapData (or via constructor): matrix based array [,] of rows and columns, each cell an integer
    ///     representing the cell from the tilesheet as a number from from 0 or 1 up to the maximum for the tilesheet and cell size
    ///     for empty cells normally supply 0 but if map generator has a different value then this can be set, note there are no gaps
    ///     so if start number is -1 then the first actual cell will be 0
    /// -  SetMapDataEmptyCellIndex: for setting the start value for SetMapData method
    /// 
    /// The following are probably not needed but may be useful:
    /// <list type="bullet">
    ///  <item>- SetFormat: this is for the 'format' section in the scene file. Defaults to 2 which is normal in Godot 3.1. No idea what this is :)</item>
    /// <item>- SetLoadSteps: in the same header section as 'format'. Defaults to 3 which is normal in Godot 3.1. Again, no idea what this is :)</item>
    /// <item>- SetNodeType: class name for the tilemap. Change if not TileMap</item>
    /// <item>- SetTileSetType: class name for the tileset. Chagne if not TileSet</item>
    /// <item>- SetNodeName: the name given to your node when you add it to the scene. Defaults to 'TileMap'</item>
    /// </list><para>
    /// Usage:
    /// Create the TileMapBuilder with optional map data and either call either method or use fluid approach to set data.
    /// Call Build method when ready and the scene file will be returned as a string.
    /// 
    /// See sample console and gui applications that provide front-ends for this.
    /// </para><example>
    /// <code>
    /// TileMapBuilder tb1 = new TileMapBuilder();
    /// TileMapBuilder tb2 = new TileMapBuilder(new int[,] { { 1, 2, 3 }, { 4, 5, 6 } });
    /// tb1.SetCellSize(32,32);
    /// tb1.SetTileSheetSizeUnits(10,10).SetMapDataEmptyCellIndex(1);
    /// string sceneFile = tb1.Build();
    /// </code></example>
    /// </summary>
    public class TileMapBuilder
    {
        //these two are generated by Godot by default
        private int sceneFormat = 2;        
        private int loadSteps = 3;
        
        //sensible defaults
        private string nodeType = "TileMap";                    //class type for the tilemap
        private string setType = "TileSet";                     //class type for the tileset

        private string nodeName = "TileMap";                    //the name of our node
        private uint cellStartIndex = 0;                        //what the start index of the tilemap is, usually 0 or 1 based
        private uint cellWidth = 32;                            //how many pixels are in each tile in the tilesheet
        private uint cellHeight = 32;           
        private uint imageWidthUnits = 0;                       //how many graphic items are in the width of the image (number, not pixels)
        private uint imageHeightUnits = 0;                      //e.g. 5 would have items 1,2,3,4,5, each cellWidth/cellHeight in size
        private string imageResource = "tilesheet.png";         //the image to bring into Godot
        private ulong cellRowSize = 65536;                      //Godot maximum width, i.e. each row is incremented by this
        private int[,] inputData=null;                          //our map data. Use whatever means of getting data in this format, e.g. CSV
        private int mapDataSkipCellNumber = -1;                 //what number in the tilemap is an empty tile. -1 for no empty tile, typically if used it is the first one
                                                                //e.g. may be 1 or 2 if 0 or 1. This number matches the cell start index value not the internal godot 0 index.

        public TileMapBuilder() { }

        /// <summary>
        /// Constructor for when you want to supply the map data with creation of the builder rather than separate
        /// <seealso cref="SetMapData"/>
        /// </summary>
        /// <param name="mapData"></param>
        public TileMapBuilder(int [,] mapData)
        {
            inputData = mapData;
        }

        /// <summary>
        /// Supply data representing a map in a 2D x/y grid, with each item being an index of the tileset
        /// If not supplied then the scene will be produced representing the tileset only, i.e. useful for importing graphics without manual 
        /// creation of tilesets within Godot
        /// </summary>
        /// <param name="mapData">Array representing a 2D tilemap, each item an index to the tileset (which is an index to the tilesheet)</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetMapData(int[,] mapData)
        {
            inputData = mapData;
            return this;
        }

        /// <summary>
        /// Specify what value in the map data represents empty cell. In a map where every cell has a graphic index
        /// but it may just represent a blank tile, or a colour that might be better represented as transparent
        /// e.g. in godot you might want to ignore a blank sky tile and instead use a coloured canvas.
        /// The default of -1 means include all (there are no blank tiles). Remember to consider the start index
        /// which may be 0 or 1. When map is read, when this value is matched it is ignored.
        /// 
        /// For example, you have set the start index to be 0 and to ignore this you specify 0 here.
        /// If you set the start index to be 1 and to ignore this you specify 1 here.
        /// Any cell can be ignored, just remember to account for the start index.
        /// </summary>
        /// <param name="startIndex">Empty cell value. Defaults to -1 which is include all</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetMapDataEmptyCellIndex(int emptyIndex)
        {
            mapDataSkipCellNumber = emptyIndex;
            return this;
        }

        /// <summary>
        /// Part of the header [gd_scene load_steps=3 format=2], modify if required
        /// </summary>
        /// <param name="format">Format of tilemap. Defaults to 2.</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetFormat(int format)
        {
            sceneFormat = format;
            return this;
        }

        /// <summary>
        /// Part of the header [gd_scene load_steps=3 format=2], modify if required
        /// </summary>
        /// <param name="steps">No idea what this does. Defaults to 3</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetLoadSteps(int steps)
        {
            loadSteps=steps;
            return this;
        }

        /// <summary>
        /// Provide a name for the tilemap node
        /// </summary>
        /// <param name="name">Node name for your scene. Defaults to TileMap</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetNodeName(string name)
        {
            nodeName = name;
            return this;
        }

        /// <summary>
        /// Class name of tilemap node.
        /// </summary>
        /// <param name="nodeType">Class type. Defaults to TileMap</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetNodeType(string nodeType)
        {
            this.nodeType = nodeType;
            return this;
        }

        /// <summary>
        /// Class of tileset node within the tilemap node
        /// </summary>
        /// <param name="setType">Class type. Defaults to TileSet</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetTileSetType(string setType)
        {
            this.setType = setType;
            return this;
        }

        /// <summary>
        /// Sets the starting index value of the tilesheet for when drawing maps 
        /// Typically 0 or 1, i.e. when reading CSV data, which is the first item
        /// </summary>
        /// <param name="index">The start index in the tilesheet used in the map CSV data, usually 0 or 1. Default 0.</param>
        /// <returns></returns>
        public TileMapBuilder SetTileSheetStartIndex(uint index)
        {
            this.cellStartIndex = index;
            return this;
        }

        /// <summary>
        /// The tilesheet is grid based with each individual cell being the same size. This sets the size.
        /// </summary>
        /// <param name="widthPixels">Width of a cell in pixels. Defaults to 32</param>
        /// <param name="heightPixels">Height of a cell in pixels. Defaults to 32</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetCellSizePixels(uint widthPixels, uint heightPixels)
        {
            this.cellHeight = heightPixels;
            this.cellWidth = widthPixels;
            return this;
        }

        /// <summary>
        /// The input graphic used by the tileset for extracting individual tileset graphic items.
        /// The library does not open or use this file, it is simply there to allow Godot to load it.
        /// </summary>
        /// <param name="filename">Name of tilesheet graphic containing the tileset stored as a grid of cells</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetTileSheet(string filename)
        {
            imageResource = filename;
            return this;
        }

        /// <summary>
        /// Whereas cellsize represents the size in pixels of each item within the tilesheet, this represents the size of
        /// the tilesheet in terms of number of cells. Used to create the right number of entries in the scene file.
        /// </summary>
        /// <param name="width">Width of tilesheet in units (e.g. 10 means 10 individual graphics across each row)</param>
        /// <param name="height">Height of tilesheet in units (e.g. 10 means 10 rows of graphics in the sheet)</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetTileSheetSizeUnits(uint width, uint height)
        {
            //redundant maths max :)
            imageHeightUnits = Math.Max(0,height);
            imageWidthUnits = Math.Max(0,width);
            return this;
        }

        /// <summary>
        /// When drawing a tilemap each location is represented by an x/y co-ordinate and a tileset item.
        /// tile_data = PoolIntArray( 0, 0, 0, 1, 0, 0, 2, 1, 0, 3, 1, 0 )
        ///                          (x, T, z, x, T, z, x, T, z, x, T, z)
        /// In a basic 2D tilemap 'x' represents the x and y co-ordinate, Because a row can have 65535 columns.
        /// Every offset from this represents a new row. I presume z is for isometric Z axis.
        /// 
        /// T is the tile index in Godot, starting with 0.
        /// </summary>
        /// <param name="width">Width of tilemap internal to Godot. Defaults to 65536</param>
        /// <returns>'this' so calls can be chained</returns>
        public TileMapBuilder SetGodotTileWidth(uint width)
        {
            cellRowSize = width;
            return this;
        }

        /// <summary>
        /// Generate the scene file as a string. Will contain a standard header, the tileset data and optional tilemap
        /// NOTE: if you use a large (and when I say large, I mean quite small (300 crashes for me) number of tileset items
        /// You need to go into Godot properties and set the maximum queue size buffer from the default of 1024 to something very large
        /// e.g. 102400. I believe it generates massive queued items (20 or so) for each tileset item, repeated.
        /// Godot will not fail nicely, it will just loop forever in the console and will have to be terminated.
        /// Seems to work better on Linux rather than Windows with regard not needing to set the queue size.
        /// </summary>
        /// <returns>Scene file as a string</returns>
        public string Build()
        {
            StringBuilder sb = new StringBuilder();

            //header
            sb.AppendLine($"[gd_scene load_steps={loadSteps} format={sceneFormat}]").AppendLine();
            sb.AppendLine($"[ext_resource path=\"res://{imageResource}\" type=\"Texture\" id=1]").AppendLine();

            //tilemap tile graphic data
            sb.AppendLine($"[sub_resource type=\"{setType}\" id=1]");
            GenerateTile(sb);
            sb.AppendLine(Environment.NewLine);

            //tilemap data
            sb.AppendLine($"[node name=\"{nodeName}\" type=\"{nodeType}\"]");
            //TODO this format line below should not be here but there's a bug making it required
            //when godot is fixed, this should be removed, but the generate map method may need to change.
            sb.AppendLine($"format=1");
            sb.AppendLine($"tile_set = SubResource( 1 )");
            sb.AppendLine($"cell_size = Vector2( {cellWidth}, {cellHeight} )");
            GenerateMap(sb);
            return sb.ToString();
        }


        /// <summary>
        /// Take the supplied data and transform to the required array format required by the builder
        /// CSV data should be comma separated for each map cell and a newline for each row, e.g.
        ///     1,1,2,3
        ///     4,2,1,3
        /// </summary>
        /// <param name="csvData">Tilemap data in string format</param>
        /// <returns>Array of data in format required by the builder</returns>
        public int[,] TransformInputData(string[] rowData)
        {
            if(rowData==null)
            {
                return null;
            }

            int rows = rowData.Length;
            string[] check = rowData[0].Split(',');
            int cols = check.Length;
            
            if (check[cols-1].Trim() == "")
            {
                cols--;
            }

            //trailing comma check
            int[,] data = new int[rows, cols];

            for (int y = 0; y < rows; y++)
            {
                string[] colData = rowData[y].Split(',');
                //skip invalid lengths
                if (colData.Length < cols || colData.Length > (cols + 1))
                {
                    Console.WriteLine($"Map data Row {y + 1}: expected {cols} (or cols+1) items. Got {colData.Length}");
                }
                else
                {
                    for (int x = 0; x < cols; x++)
                    {
                        data[y, x] = Convert.ToInt32(colData[x]);
                    }
                }
            }

            return data;
        }

        /// <summary>
        /// Creates tilemap entry. Godot tilesheet items will start from 0 always.
        /// Map data may start at 0 or 1 (or something else) so it is adjusted so
        /// whatever is the start, will match
        /// </summary>
        /// <param name="sb"></param>
        private void GenerateMap(StringBuilder sb)
        {
            /*
              tile_data = PoolIntArray( 0, 0, 0, 1, 0, 0, 2, 1, 0, 3, 1, 0 )
                                      ( x, T, z, x, T, z, x, T, z, x, T, z )
             items are in groups of 3: x, tile, z
             empty items are not represented so whatever we set our empty cell to, we ignore that
             X becomes the X and Y because for each row add 65536 as that is the maximum number of tiles in a column
             Z is always 0 as this is a basic 2D map.
             
              */
            //data guard
            if (inputData == null || inputData.GetLength(0) == 0 || inputData.GetLength(1) == 0)
            {
                return;
            }

            sb.Append($"tile_data = PoolIntArray( ");
            for (int y=0;y<inputData.GetLength(0);y++)
            {
                for (int x = 0; x < inputData.GetLength(1); x++)
                {
                    //the map is a square array, i.e. [,]
                    //supplied csv might be 0 or 1 indexed to represent empty
                    int currentTile = inputData[y, x];
                    //only process if not the empty cell
                    if (currentTile != mapDataSkipCellNumber || mapDataSkipCellNumber == -1)
                    {
                        //godot always starts with 0 so need to offset
                        sb.Append($"{Convert.ToUInt64(x)+((ulong)y * cellRowSize)}, {currentTile- cellStartIndex}, 0, ");
                        //if(x<(inputData.GetLength(1)-1) || y<(inputData.GetLength(0)-1))
                        //{
                        //    sb.Append(", ");
                        //}
                    }
                }
            }
            sb.Remove(sb.Length - 2, 2);
            sb.Append($" )");
        }

        /// <summary>
        /// Creates the tileset entries for each item in the tilesheet
        /// This will always make first item 0 and match the first item in the tilesheet
        /// so if map data is supplied it is adjusted to ensure its start index matches 0
        /// typically map data is 0 or 1
        /// </summary>
        /// <param name="sb"></param>
        private void GenerateTile(StringBuilder sb)
        {
            /*
                0/name = "tiles.png 0"
                0/texture = ExtResource( 1 )
                0/tex_offset = Vector2( 0, 0 )
                0/modulate = Color( 1, 1, 1, 1 )
                0/region = Rect2( 0, 0, 32, 32 )    ********** the value that changes *********
                    Rect2( X, Y, Width, Height )
                       X is per pixel width increment
                       Y is per pixel height increment
                0/tile_mode = 0
                0/occluder_offset = Vector2( 0, 0 )
                0/navigation_offset = Vector2( 0, 0 )
                0/shapes = [  ]
                0/z_index = 0
            */

            int counter = 0;
            for (int rows = 0; rows < imageHeightUnits; rows++)
            {
                for (int cols = 0; cols < imageWidthUnits; cols++)
                {
                    sb.Append($"{counter}/name = \"{imageResource} {counter:00000}\"").Append(Environment.NewLine);
                    sb.Append($"{counter}/texture = ExtResource( 1 )").Append(Environment.NewLine);
                    sb.Append($"{counter}/tex_offset = Vector2( 0, 0 )").Append(Environment.NewLine);
                    sb.Append($"{counter}/modulate = Color( 1, 1, 1, 1 )").Append(Environment.NewLine);
                    sb.Append($"{counter}/region = Rect2( {cols*cellWidth}, {rows*cellHeight}, {cellWidth}, {cellHeight} )").Append(Environment.NewLine);
                    sb.Append($"{counter}/tile_mode = 0").Append(Environment.NewLine);
                    sb.Append($"{counter}/occluder_offset = Vector2( 0, 0 )").Append(Environment.NewLine);
                    sb.Append($"{counter}/navigation_offset = Vector2( 0, 0 )").Append(Environment.NewLine);
                    sb.Append($"{counter}/shapes = [  ]").Append(Environment.NewLine);
                    sb.Append($"{counter}/z_index = 0").Append(Environment.NewLine);

                    counter++;
                }
            }
        }
    }
}
